diff --git a/widget/gtk/WindowSurfaceWayland.h b/widget/gtk/WindowSurfaceWayland.h
--- a/widget/gtk/WindowSurfaceWayland.h
+++ b/widget/gtk/WindowSurfaceWayland.h
@@ -204,7 +204,6 @@
       const LayoutDeviceIntRegion& aRegion,
       LayoutDeviceIntRegion& aWaylandBufferDamage);
   void CommitWaylandBuffer();
-  void CalcRectScale(LayoutDeviceIntRect& aRect, int scale);
 
   void DrawDelayedImageCommits(gfx::DrawTarget* aDrawTarget,
                                LayoutDeviceIntRegion& aWaylandBufferDamage);
diff --git a/widget/gtk/WindowSurfaceWayland.cpp b/widget/gtk/WindowSurfaceWayland.cpp
--- a/widget/gtk/WindowSurfaceWayland.cpp
+++ b/widget/gtk/WindowSurfaceWayland.cpp
@@ -951,16 +951,6 @@
   }
 }
 
-void WindowSurfaceWayland::CalcRectScale(LayoutDeviceIntRect& aRect,
-                                         int aScale) {
-  aRect.x = aRect.x / aScale;
-  aRect.y = aRect.y / aScale;
-
-  // We don't need exact damage size - just safely cover the round errors.
-  aRect.width = (aRect.width / aScale) + 2;
-  aRect.height = (aRect.height / aScale) + 2;
-}
-
 void WindowSurfaceWayland::CommitWaylandBuffer() {
   MOZ_ASSERT(mPendingCommit, "Committing empty surface!");
 
@@ -1022,16 +1012,10 @@
     mWholeWindowBufferDamage = false;
     mNeedScaleFactorUpdate = true;
   } else {
-    gint scaleFactor = mWindow->GdkScaleFactor();
     for (auto iter = mWaylandBufferDamage.RectIter(); !iter.Done();
          iter.Next()) {
       mozilla::LayoutDeviceIntRect r = iter.Get();
-      // We need to remove the scale factor because the wl_surface_damage
-      // also multiplies by current  scale factor.
-      if (scaleFactor > 1) {
-        CalcRectScale(r, scaleFactor);
-      }
-      wl_surface_damage(waylandSurface, r.x, r.y, r.width, r.height);
+      wl_surface_damage_buffer(waylandSurface, r.x, r.y, r.width, r.height);
     }
   }
 
diff --git a/widget/gtk/mozcontainer.cpp b/widget/gtk/mozcontainer.cpp
--- a/widget/gtk/mozcontainer.cpp
+++ b/widget/gtk/mozcontainer.cpp
@@ -578,16 +578,12 @@
       return nullptr;
     }
     GdkDisplay* display = gtk_widget_get_display(GTK_WIDGET(container));
+    nsWaylandDisplay* waylandDisplay = WaylandDisplayGet(display);
 
     // Available as of GTK 3.8+
-    static auto sGdkWaylandDisplayGetWlCompositor =
-        (wl_compositor * (*)(GdkDisplay*))
-            dlsym(RTLD_DEFAULT, "gdk_wayland_display_get_wl_compositor");
-    struct wl_compositor* compositor =
-        sGdkWaylandDisplayGetWlCompositor(display);
+    struct wl_compositor* compositor = waylandDisplay->GetCompositor();
     container->surface = wl_compositor_create_surface(compositor);
 
-    nsWaylandDisplay* waylandDisplay = WaylandDisplayGet(display);
     container->subsurface = wl_subcompositor_get_subsurface(
         waylandDisplay->GetSubcompositor(), container->surface,
         moz_container_get_gtk_container_surface(container));
diff --git a/widget/gtk/mozwayland/mozwayland.h b/widget/gtk/mozwayland/mozwayland.h
--- a/widget/gtk/mozwayland/mozwayland.h
+++ b/widget/gtk/mozwayland/mozwayland.h
@@ -108,6 +108,17 @@
 }
 #endif
 
+#ifndef WL_SURFACE_DAMAGE_BUFFER
+#  define WL_SURFACE_DAMAGE_BUFFER 9
+
+static inline void wl_surface_damage_buffer(struct wl_surface* wl_surface,
+                                            int32_t x, int32_t y, int32_t width,
+                                            int32_t height) {
+  wl_proxy_marshal((struct wl_proxy*)wl_surface, WL_SURFACE_DAMAGE_BUFFER, x, y,
+                   width, height);
+}
+#endif
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/widget/gtk/mozwayland/mozwayland.c b/widget/gtk/mozwayland/mozwayland.c
--- a/widget/gtk/mozwayland/mozwayland.c
+++ b/widget/gtk/mozwayland/mozwayland.c
@@ -30,6 +30,7 @@
 const struct wl_interface wl_seat_interface;
 const struct wl_interface wl_surface_interface;
 const struct wl_interface wl_subsurface_interface;
+const struct wl_interface wl_compositor_interface;
 const struct wl_interface wl_subcompositor_interface;
 #pragma GCC visibility pop
 
diff --git a/widget/gtk/nsWaylandDisplay.h b/widget/gtk/nsWaylandDisplay.h
--- a/widget/gtk/nsWaylandDisplay.h
+++ b/widget/gtk/nsWaylandDisplay.h
@@ -45,6 +45,7 @@
   MessageLoop* GetDispatcherThreadLoop() { return mDispatcherThreadLoop; }
   wl_display* GetDisplay() { return mDisplay; };
   wl_event_queue* GetEventQueue() { return mEventQueue; };
+  wl_compositor* GetCompositor(void) { return mCompositor; };
   wl_subcompositor* GetSubcompositor(void) { return mSubcompositor; };
   wl_data_device_manager* GetDataDeviceManager(void) {
     return mDataDeviceManager;
@@ -56,6 +57,7 @@
   };
 
   void SetShm(wl_shm* aShm);
+  void SetCompositor(wl_compositor* aCompositor);
   void SetSubcompositor(wl_subcompositor* aSubcompositor);
   void SetDataDeviceManager(wl_data_device_manager* aDataDeviceManager);
   void SetSeat(wl_seat* aSeat);
@@ -88,6 +90,7 @@
   wl_display* mDisplay;
   wl_event_queue* mEventQueue;
   wl_data_device_manager* mDataDeviceManager;
+  wl_compositor* mCompositor;
   wl_subcompositor* mSubcompositor;
   wl_seat* mSeat;
   wl_shm* mShm;
diff --git a/widget/gtk/nsWaylandDisplay.cpp b/widget/gtk/nsWaylandDisplay.cpp
--- a/widget/gtk/nsWaylandDisplay.cpp
+++ b/widget/gtk/nsWaylandDisplay.cpp
@@ -116,6 +116,10 @@
 
 void nsWaylandDisplay::SetShm(wl_shm* aShm) { mShm = aShm; }
 
+void nsWaylandDisplay::SetCompositor(wl_compositor* aCompositor) {
+  mCompositor = aCompositor;
+}
+
 void nsWaylandDisplay::SetSubcompositor(wl_subcompositor* aSubcompositor) {
   mSubcompositor = aSubcompositor;
 }
@@ -223,6 +227,12 @@
     wl_proxy_set_queue((struct wl_proxy*)primary_selection_device_manager,
                        display->GetEventQueue());
     display->SetPrimarySelectionDeviceManager(primary_selection_device_manager);
+  } else if (strcmp(interface, "wl_compositor") == 0) {
+    // Requested wl_compositor version 4 as we need wl_surface_damage_buffer().
+    auto compositor = static_cast<wl_compositor*>(
+        wl_registry_bind(registry, id, &wl_compositor_interface, 4));
+    wl_proxy_set_queue((struct wl_proxy*)compositor, display->GetEventQueue());
+    display->SetCompositor(compositor);
   } else if (strcmp(interface, "wl_subcompositor") == 0) {
     auto subcompositor = static_cast<wl_subcompositor*>(
         wl_registry_bind(registry, id, &wl_subcompositor_interface, 1));
@@ -306,6 +316,7 @@
       mDisplay(aDisplay),
       mEventQueue(nullptr),
       mDataDeviceManager(nullptr),
+      mCompositor(nullptr),
       mSubcompositor(nullptr),
       mSeat(nullptr),
       mShm(nullptr),

