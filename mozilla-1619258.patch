changeset:   519528:3c63c1d6df70
parent:      519514:7ac664c14598
user:        Martin Stransky <stransky@redhat.com>
date:        Wed Mar 04 12:46:41 2020 +0100
files:       dom/media/platforms/ffmpeg/FFmpegVideoDecoder.cpp dom/media/platforms/ffmpeg/FFmpegVideoDecoder.h
description:
Bug 1619258 [Wayland] Enable VA-API for all formats, r?jya

Differential Revision: https://phabricator.services.mozilla.com/D65536


diff --git a/dom/media/platforms/ffmpeg/FFmpegVideoDecoder.cpp b/dom/media/platforms/ffmpeg/FFmpegVideoDecoder.cpp
--- a/dom/media/platforms/ffmpeg/FFmpegVideoDecoder.cpp
+++ b/dom/media/platforms/ffmpeg/FFmpegVideoDecoder.cpp
@@ -130,20 +130,16 @@ VAAPIFrameHolder::VAAPIFrameHolder(FFmpe
 
 VAAPIFrameHolder::~VAAPIFrameHolder() {
   mLib->av_buffer_unref(&mHWFrame);
   mLib->av_buffer_unref(&mAVHWFramesContext);
   mLib->av_buffer_unref(&mVAAPIDeviceContext);
 }
 
 AVCodec* FFmpegVideoDecoder<LIBAV_VER>::FindVAAPICodec() {
-  if (mCodecID != AV_CODEC_ID_H264) {
-    return nullptr;
-  }
-
   AVCodec* decoder = mLib->avcodec_find_decoder(mCodecID);
   for (int i = 0;; i++) {
     const AVCodecHWConfig* config = mLib->avcodec_get_hw_config(decoder, i);
     if (!config) {
       break;
     }
     if (config->methods & AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX &&
         config->device_type == AV_HWDEVICE_TYPE_VAAPI) {
@@ -167,17 +163,16 @@ bool FFmpegVideoDecoder<LIBAV_VER>::Crea
   }
 
   mCodecContext->hw_device_ctx = mLib->av_buffer_ref(mVAAPIDeviceContext);
   return true;
 }
 
 MediaResult FFmpegVideoDecoder<LIBAV_VER>::InitVAAPIDecoder() {
   FFMPEG_LOG("Initialising VA-API FFmpeg decoder");
-  MOZ_ASSERT(mCodecID == AV_CODEC_ID_H264);
 
   if (!mLib->IsVAAPIAvailable()) {
     FFMPEG_LOG("libva library is missing");
     return NS_ERROR_NOT_AVAILABLE;
   }
 
   if (!gfxPlatformGtk::GetPlatform()->UseWaylandHardwareVideoDecoding()) {
     FFMPEG_LOG("VA-API FFmpeg is disabled by platform");
@@ -277,21 +272,19 @@ FFmpegVideoDecoder<LIBAV_VER>::FFmpegVid
   mExtraData = new MediaByteBuffer;
   mExtraData->AppendElements(*aConfig.mExtraData);
 }
 
 RefPtr<MediaDataDecoder::InitPromise> FFmpegVideoDecoder<LIBAV_VER>::Init() {
   MediaResult rv;
 
 #ifdef MOZ_WAYLAND_USE_VAAPI
-  if (mCodecID == AV_CODEC_ID_H264) {
-    rv = InitVAAPIDecoder();
-    if (NS_SUCCEEDED(rv)) {
-      return InitPromise::CreateAndResolve(TrackInfo::kVideoTrack, __func__);
-    }
+  rv = InitVAAPIDecoder();
+  if (NS_SUCCEEDED(rv)) {
+    return InitPromise::CreateAndResolve(TrackInfo::kVideoTrack, __func__);
   }
 #endif
 
   rv = InitDecoder();
   if (NS_SUCCEEDED(rv)) {
     return InitPromise::CreateAndResolve(TrackInfo::kVideoTrack, __func__);
   }
 
@@ -692,9 +685,16 @@ void FFmpegVideoDecoder<LIBAV_VER>::Proc
 #ifdef MOZ_WAYLAND_USE_VAAPI
   if (mVAAPIDeviceContext) {
     mLib->av_buffer_unref(&mVAAPIDeviceContext);
   }
 #endif
   FFmpegDataDecoder<LIBAV_VER>::ProcessShutdown();
 }
 
+#ifdef MOZ_WAYLAND_USE_VAAPI
+bool FFmpegVideoDecoder<LIBAV_VER>::IsHardwareAccelerated(
+    nsACString& aFailureReason) const {
+  return mVAAPIDeviceContext != nullptr;
+}
+#endif
+
 }  // namespace mozilla
diff --git a/dom/media/platforms/ffmpeg/FFmpegVideoDecoder.h b/dom/media/platforms/ffmpeg/FFmpegVideoDecoder.h
--- a/dom/media/platforms/ffmpeg/FFmpegVideoDecoder.h
+++ b/dom/media/platforms/ffmpeg/FFmpegVideoDecoder.h
@@ -87,16 +87,17 @@ class FFmpegVideoDecoder<LIBAV_VER>
   MediaResult CreateImage(int64_t aOffset, int64_t aPts, int64_t aDuration,
                           MediaDataDecoder::DecodedData& aResults);
 
 #ifdef MOZ_WAYLAND_USE_VAAPI
   MediaResult InitVAAPIDecoder();
   bool CreateVAAPIDeviceContext();
   void InitVAAPICodecContext();
   AVCodec* FindVAAPICodec();
+  bool IsHardwareAccelerated(nsACString& aFailureReason) const override;
 
   MediaResult CreateImageVAAPI(int64_t aOffset, int64_t aPts, int64_t aDuration,
                                MediaDataDecoder::DecodedData& aResults);
 #endif
 
   /**
    * This method allocates a buffer for FFmpeg's decoder, wrapped in an Image.
    * Currently it only supports Planar YUV420, which appears to be the only

