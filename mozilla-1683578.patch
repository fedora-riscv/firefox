diff -up firefox-86.0/widget/gtk/nsWindow.cpp.1683578 firefox-86.0/widget/gtk/nsWindow.cpp
--- firefox-86.0/widget/gtk/nsWindow.cpp.1683578	2021-02-24 10:09:53.471680954 +0100
+++ firefox-86.0/widget/gtk/nsWindow.cpp	2021-02-24 10:09:53.510681881 +0100
@@ -1769,6 +1769,9 @@ void nsWindow::NativeMoveResizeWaylandPo
   bool isWidgetVisible =
       (sGtkWidgetIsVisible != nullptr) && sGtkWidgetIsVisible(mShell);
   if (isWidgetVisible) {
+    LOG(
+        ("  temporary hide popup due to "
+         "https://gitlab.gnome.org/GNOME/gtk/issues/1986\n"));
     PauseRemoteRenderer();
     gtk_widget_hide(mShell);
   }
@@ -1823,6 +1826,9 @@ void nsWindow::NativeMoveResizeWaylandPo
   if (isWidgetVisible) {
     // We show the popup with the same configuration so no need to call
     // ConfigureWaylandPopupWindows() before gtk_widget_show().
+    LOG(
+        ("  show popup due to "
+         "https://gitlab.gnome.org/GNOME/gtk/issues/1986\n"));
     gtk_widget_show(mShell);
   }
 }
diff -up firefox-86.0/widget/gtk/WindowSurfaceWayland.cpp.1683578 firefox-86.0/widget/gtk/WindowSurfaceWayland.cpp
--- firefox-86.0/widget/gtk/WindowSurfaceWayland.cpp.1683578	2021-02-22 15:47:05.000000000 +0100
+++ firefox-86.0/widget/gtk/WindowSurfaceWayland.cpp	2021-02-24 10:12:59.835110678 +0100
@@ -467,7 +467,7 @@ WindowSurfaceWayland::WindowSurfaceWayla
       mWaylandBuffer(nullptr),
       mWaylandFullscreenDamage(false),
       mFrameCallback(nullptr),
-      mLastCommittedSurface(nullptr),
+      mLastCommittedSurfaceID(-1),
       mLastCommitTime(0),
       mDrawToWaylandBufferDirectly(true),
       mCanSwitchWaylandBuffer(true),
@@ -964,7 +964,7 @@ bool WindowSurfaceWayland::FlushPendingC
       ("   mDrawToWaylandBufferDirectly = %d\n", mDrawToWaylandBufferDirectly));
   LOGWAYLAND(("   mCanSwitchWaylandBuffer = %d\n", mCanSwitchWaylandBuffer));
   LOGWAYLAND(("   mFrameCallback = %p\n", mFrameCallback));
-  LOGWAYLAND(("   mLastCommittedSurface = %p\n", mLastCommittedSurface));
+  LOGWAYLAND(("    mLastCommittedSurfaceID = %d\n", mLastCommittedSurfaceID));
   LOGWAYLAND(("   mBufferPendingCommit = %d\n", mBufferPendingCommit));
   LOGWAYLAND(("   mBufferCommitAllowed = %d\n", mBufferCommitAllowed));
 
@@ -990,12 +990,6 @@ bool WindowSurfaceWayland::FlushPendingC
     LOGWAYLAND(("    [%p] mWindow->GetWaylandSurface() failed, delay commit.\n",
                 (void*)this));
 
-    // Target window is not created yet - delay the commit. This can happen only
-    // when the window is newly created and there's no active
-    // frame callback pending.
-    MOZ_ASSERT(!mFrameCallback || waylandSurface != mLastCommittedSurface,
-               "Missing wayland surface at frame callback!");
-
     if (!mSurfaceReadyTimerID) {
       mSurfaceReadyTimerID = g_timeout_add(
           EVENT_LOOP_DELAY, &WaylandBufferFlushPendingCommits, this);
@@ -1016,8 +1010,10 @@ bool WindowSurfaceWayland::FlushPendingC
 
   // We have an active frame callback request so handle it.
   if (mFrameCallback) {
-    if (waylandSurface == mLastCommittedSurface) {
-      LOGWAYLAND(("    [%p] wait for frame callback.\n", (void*)this));
+    int waylandSurfaceID = wl_proxy_get_id((struct wl_proxy*)waylandSurface);
+    if (waylandSurfaceID == mLastCommittedSurfaceID) {
+      LOGWAYLAND(("    [%p] wait for frame callback ID %d.\n", (void*)this,
+                  waylandSurfaceID));
       // We have an active frame callback pending from our recent surface.
       // It means we should defer the commit to FrameCallbackHandler().
       return true;
@@ -1026,7 +1022,7 @@ bool WindowSurfaceWayland::FlushPendingC
     // callback is no longer active and we should release it.
     wl_callback_destroy(mFrameCallback);
     mFrameCallback = nullptr;
-    mLastCommittedSurface = nullptr;
+    mLastCommittedSurfaceID = -1;
   }
 
   if (mWaylandFullscreenDamage) {
@@ -1055,7 +1051,7 @@ bool WindowSurfaceWayland::FlushPendingC
   wl_callback_add_listener(mFrameCallback, &frame_listener, this);
 
   mWaylandBuffer->Attach(waylandSurface);
-  mLastCommittedSurface = waylandSurface;
+  mLastCommittedSurfaceID = wl_proxy_get_id((struct wl_proxy*)waylandSurface);
   mLastCommitTime = g_get_monotonic_time() / 1000;
 
   // There's no pending commit, all changes are sent to compositor.
@@ -1097,7 +1093,7 @@ void WindowSurfaceWayland::Commit(const
 void WindowSurfaceWayland::FrameCallbackHandler() {
   MOZ_ASSERT(mFrameCallback != nullptr,
              "FrameCallbackHandler() called without valid frame callback!");
-  MOZ_ASSERT(mLastCommittedSurface != nullptr,
+  MOZ_ASSERT(mLastCommittedSurfaceID != -1,
              "FrameCallbackHandler() called without valid wl_surface!");
   LOGWAYLAND(
       ("WindowSurfaceWayland::FrameCallbackHandler [%p]\n", (void*)this));
diff -up firefox-86.0/widget/gtk/WindowSurfaceWayland.h.1683578 firefox-86.0/widget/gtk/WindowSurfaceWayland.h
--- firefox-86.0/widget/gtk/WindowSurfaceWayland.h.1683578	2021-02-22 15:47:05.000000000 +0100
+++ firefox-86.0/widget/gtk/WindowSurfaceWayland.h	2021-02-24 10:09:53.509681857 +0100
@@ -215,7 +215,7 @@ class WindowSurfaceWayland : public Wind
   // Any next commit to wayland compositor will happen when frame callback
   // comes from wayland compositor back as it's the best time to do the commit.
   wl_callback* mFrameCallback;
-  wl_surface* mLastCommittedSurface;
+  int mLastCommittedSurfaceID;
 
   // Cached drawings. If we can't get WaylandBuffer (wl_buffer) at
   // WindowSurfaceWayland::Lock() we direct gecko rendering to
